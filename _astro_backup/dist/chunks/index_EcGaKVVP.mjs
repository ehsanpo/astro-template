const id = "typescript-best-practices/index.md";
						const collection = "blog";
						const slug = "typescript-best-practices";
						const body = "\nHey friends ‚Äî I‚Äôve been fiddling with TypeScript lately, trying to understand all those little gotchas. One thing that kept biting me was **excess property checks**, plus the difference between `object`, `{}`, `Object` types. I want to share what I learned, because earlier I was confused, maybe you will too, and maybe this helps you avoid stepping on the same banana peel üçå.\n\n---\n\n### What even _are_ excess property checks?\n\nSo imagine I define:\n\n```ts\ntype Person = { firstName: string; age: number };\n\nfunction logPerson(person: Person) {\n\tconsole.log(person);\n}\n```\n\nThen I try\n\n```ts\nconst person2: Person = { firstName: \"potato\", age: 21, extraProp: \"hello!\" }; // <-- error\n```\n\nAt first I was like ‚Äúwtf, I thought TypeScript was structural, isn‚Äôt extraProp ok if it has all the required ones?‚Äù But no ‚Äî TS is stricter when you assign an _object literal_ directly to a typed variable (or pass literal directly to a function). It checks: ‚Äúdoes this literal have any properties I don‚Äôt know about (i.e. not in the target type)?‚Äù If yes ‚Üí error. That‚Äôs the ‚Äúexcess property check.‚Äù ([TypeScript][1])\n\nBut then, I did this:\n\n```ts\nconst person3: Person = {\n\tfirstName: \"potato\",\n\tage: 21,\n\t...{ extraProp: \"hello!\" },\n}; // fine\n```\n\nAND it passed. And I was like ‚Äúomg why?‚Äù ü§î Turns out: because of how TS handles spreads and variables/inference. If you spread in extra props, or assign literal to a variable first, TS doesn‚Äôt always trigger that excess prop check. The literal isn‚Äôt ‚Äúfresh‚Äù in a sense, so TS is more forgiving. ([allthingstypescript.dev][2])\n\n---\n\n### Why this behavior exists (and my struggle)\n\n- It‚Äôs super helpful for catching little mistakes: typos, misspelling property names, etc. For example, you meant `color` but typed `colour`, TS might warn. ([TypeScript][1])\n- But the inconsistency annoyed me. I kept wondering: ‚Äúwhy does doing `.push(...)` in one case break, but in another, no?‚Äù Or ‚Äúwhy does spreading let me sneak extra props in?‚Äù\n- Eventually I saw: TS is structural (duck typing), but it gives special treatment to object _literals_ when creating or assigning them. If something has already been inferred (object assigned to a variable first), then ‚Äúexcess property‚Äù checks are often skipped. ([allthingstypescript.dev][2])\n\nSo yeah, it feels inconsistent if you don‚Äôt know the rules. But once you know them, you can predict what will happen. (Still sometimes surprises me, don‚Äôt lie.)\n\n---\n\n### `object` vs `{}` vs `Object` ‚Äî my head almost exploded\n\nWhile learning excess props, I also got confused about these three. They seem like they'd be the same, but noooo. TS is picky in its own special way. Here‚Äôs how I think of them (after many StackOverflow lurks + making tiny example code to test) :\n\n| let foo: object;                                                                                                                             | let foo : {};                                                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| <br>foo = { hello: 0}; ‚úÖ<br>foo = []; ‚úÖ<br>foo = false;‚ùå<br>foo = null;‚ùå<br>foo = undefined; ‚ùå<br>foo = 42;‚ùå<br>foo = 'bar';‚ùå<br><br> | <br>foo = { hello: 0}; ‚úÖ<br>foo = [];‚úÖ<br>foo = false;‚úÖ<br>foo = null;‚ùå<br>foo = undefined;‚ùå<br>foo = 42; ‚úÖ<br>foo = 'bar'‚úÖ |\n|                                                                                                                                              |                                                                                                                                    |\n\n| Type                     | What it allows                                                                                                           | What it forbids                                                                                            | When I might use it                                                                            |\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |\n| `object` (lowercase)     | non-primitive things: objects, arrays, functions etc. ([DEV Community][3])                                               | primitives like number, string, boolean, symbol etc. ([DEV Community][3])                                  | When I really want ‚Äúthis must be an object (or array etc.), not just a string or number‚Äù       |\n| `{}` (empty object type) | almost everything except `null` or `undefined` ‚Äî yes you can pass string, number, bool etc. ([Type-Level TypeScript][4]) | basically only `null` and `undefined` are excluded (if `strictNullChecks` on) ([Type-Level TypeScript][4]) | When I don‚Äôt care much about structure, or I want super loose type (but that‚Äôs dangerous)      |\n| `Object` (capital O)     | similar to `{}`, lots of overlap; but has some weirdness, prototypical methods etc. ([jser.dev][5])                      | maybe stricter in some built-in method typings; also semantically confusing (some people avoid using it)   | I try to avoid; if I use it, it‚Äôs for ‚Äújust anything with the base Object‚Äù but clarity suffers |\n\nSo: if I want more type safety, `object` is usually safer than `{}` in my code. `{}` is too broad; you can accidentally pass a `\"hello\"` or `123` and TS won‚Äôt complain. (Yes, I tested this.) ([Type-Level TypeScript][4])\n\n---\n\n### That ‚Äúarray union‚Äù snippet & mutation weirdness\n\nYou also gave the snippet:\n\n```ts\nconst foo: string[] = [\"1\", \"2\"];\n\nfunction bar(things: (number | string)[]) {\n\tthings.push(3); // passes type check\n}\nbar(foo);\n```\n\nI remember doing similar stupid stuff. What‚Äôs going on:\n\n- `foo` is `string[]`\n- `bar` wants `(number|string)[]`\n- Because every `string` is acceptable where `(number|string)` is expected, `string[]` is assignable to `(string|number)[]`. (Covariance in this context)\n- So TS lets you call `bar(foo)`. Then inside `bar`, pushing `3` (a number) is allowed because the type of `things` is `(string|number)[]`. So at runtime, you end up with a mix. Type safety is ‚Äúok‚Äù by TS‚Äôs rules, but logically your `foo` array has now numbers in it (which you might not expect). Scary.\n\nSo TS gives you power, but also begs you to pay attention. If I want safer, I might use `readonly string[]` or avoid that mutation. (One of my dev regrets: I didn‚Äôt use readonly arrays earlier.)\n\n---\n\n### My ‚Äúaha!‚Äù moments & little tips\n\nHere are some bits I picked up that really helped me stop banging my head:\n\n- If you want to catch extra props always, try to annotate variables explicitly rather than letting TS infer, especially with literals. The moment you introduce a variable, sometimes the excess check is skipped.\n- Use **spreads** carefully. Spreads sometimes ‚Äúhide‚Äù excess props, which might be what you want, but sometimes what you _don‚Äôt want_, so know when it happens.\n- Consider tools / lint rules. There are TS/ESLint rules that enforce stricter property checks, type assertions policies etc. These help keep things consistent.\n- Be conservative with `object`, `{}` etc. If you know your data shape, define interface/type. Don‚Äôt default to ‚Äúanything goes.‚Äù Saves future debugging.\n\n---\n\n### Final thoughts (because I'm still learning!)\n\nHonestly, understanding these quirks felt like unlocking secret levels in TS. Sometimes I feel TS is beautiful, other times it's like one more trap waiting. But the more I write, experiment, make mistakes (omg so many), the more these behavior patterns stick.\n\nIf you‚Äôre a beginner: don‚Äôt let it discourage you. It‚Äôs OK to get weird errors. Try small isolated examples like above. Try modifying them and see what TS complains about. Throw in a spread, move to variable first, assign literal, pass directly to function ‚Äî see where TS flips. That kind of play is what taught me.\n\nIf you want, I can write up a mini-cheat sheet you can keep open, with all these ‚Äúwhen does excess prop check happen / when not / object vs {} etc.‚Äù Want me to drop that?\n\n[1]: https://www.typescriptlang.org/docs/handbook/2/objects.html?utm_source=chatgpt.com \"Documentation - Object Types\"\n[2]: https://www.allthingstypescript.dev/p/mid-week-scoop-understanding-excess/comments?utm_source=chatgpt.com \"Mid-week Scoop: Understanding Excess Property Checking in ...\"\n[3]: https://dev.to/dipakahirav/differences-between-object-and-object-in-typescript-4cca?utm_source=chatgpt.com \"Differences Between Object, {}, and object in TypeScript\"\n[4]: https://type-level-typescript.com/articles/difference-between-object-types-in-typescript?utm_source=chatgpt.com \"what's the difference between object and {} in TypeScript?\"\n[5]: https://jser.dev/typescript/2023/01/12/typescript-object-Object/?utm_source=chatgpt.com \"`{}` vs `object` vs `Object` in TypeScript.\"\n";
						const data = {title:"My TypeScript Adventures: Excess Props, `object` vs `{}`, and Why My Code Sometimes Explodess",description:"Tripped over excess property checks in TypeScript ‚Äî sharing what I learned so you don‚Äôt.",date:"2025-09-24",author:"Ehsan Pourhadi",category:["TypeScript","Best Practices"],tag:["TypeScript","JavaScript","Development","Code Quality"],cover:
						new Proxy({"src":"/_astro/cover.BUes_Z9a.png","width":2816,"height":1536,"format":"png","fsPath":"C:/Users/Ehsan/dev/astro-template/src/content/blog/typescript-best-practices/cover.png"}, {
						get(target, name, receiver) {
							if (name === 'clone') {
								return structuredClone(target);
							}
							if (name === 'fsPath') {
								return "C:/Users/Ehsan/dev/astro-template/src/content/blog/typescript-best-practices/cover.png";
							}
							if (target[name] !== undefined && globalThis.astroAsset) globalThis.astroAsset?.referencedImages.add("C:/Users/Ehsan/dev/astro-template/src/content/blog/typescript-best-practices/cover.png");
							return target[name];
						}
					})
					,featured:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/Ehsan/dev/astro-template/src/content/blog/typescript-best-practices/index.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
